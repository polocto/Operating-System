# Semaphores

>How can we use semaphores instead of locks and condition variables?

>What is the definition of a semaphore?

>What is a binary semaphore?

>Is it straightforward to build a semaphore out of locks and condition variables?

>To build locks and condition variables out of semaphores?

## A Defenition

A **semaphore** is an object with an **int** value that can be manipulate by `sem_wait()` & `sem_post()`. **Semaphore** can be shared by threads from a same process. **Semaphore declaration:**
```c
#include <semaphore.h>
sem_t s; //declaration of a semaphore variable
sem_init(&s, 0, 1); //sem_init(variable, config, value);
```
Once the **semaphore variable** is declare we can call the two function: `sem_wait()` & `sem_post()`. We have to be very careful about how we going to call those **[critical section](26.Threads-Intro.md#glossary)**.

```c
int sem_wait(sem_t*s) 
{
    //decrement the value of semaphore s by one
    //wait if value of semaphore s is negative
}

int sem_post(sem_t*s) 
{
    //increment the value of semaphore s by one
    //if there are one or more threads waiting, wake one
}
```
When the **semaphore's value is negative**, it is equal to the **number of waiting threads**.

## Binary Semaphores (Locks)

### Use Semaphores as a lock
```c
sem_t m;
sem_init(&m, 0, X); // initialize to X; what should X be?

sem_wait(&m);
// critical section here
sem_post(&m);
```
>X should be equal to 1

**`sem_wait();` decrements** the value of the semaphores. It will wait if the **semaphore <= 0**. This let *Thread 0* **continue** and enter the **critical section**.

If no other **threads** try to acquire the **lock** while *Thread 0* is in the **critical section**, when `sem_post()` is called the **sempahore**'s value will be **restore to 1**.

### Thread Trace: Single Thread Using A Semaphore
| Value of Sempahore    | Thread 0              | Thread 1      |
| :-:                   |:-:                    | :-:           |
|1                      |                       |               |
|1                      |call `sem_wait()`      |               |
|0                      |`sem_wait()` returns   |               |
|0                      |**critical section**   |               |
|0                      |call `sem_post()`      |               |
|1                      |`sem_post()` returns   |               |

When *Thread 0* is running **semaphore's value = 0**, when another **thread** start running the semaphore value is decrease to **-1**. Then the second **thread** *Thread 1* goes to **sleep** waiting to be **wake up** when  *Thread 0* will arrives to end and run again when the **semaphore**'s value is **increased**.

>Note that Thread 1 goes into the sleeping state when ittries toacquire the already-held lock; only when Thread 0 runs again can Thread1 be awoken and potentially run again.

Thus we are able to use **semaphores** as **locks**. Because locks only have **two states** (held and not held), we sometimes call a semaphore used as a lock a **binary semaphore**. Note that if you are using a semaphore only in this binary fashion, it could be implemented in a simpler manner than the generalized semaphores we present here.

## Semaphores For Ordering

```c
sem_t s;
void *child(void *arg) {
    printf("child\n");
    sem_post(&s); // signal here: child is done
    return NULL;
}
int main(int argc, char *argv[]) {
    sem_init(&s, 0, X); // what should X be? => 1
    printf("parent: begin\n");
    pthread_t c;
    Pthread_create(&c, NULL, child, NULL);
    sem_wait(&s); // wait here for child
    printf("parent: end\n");
    return 0;
}
```
In this pattern of usage, we often find one **thread** **waiting** for **something** to happen, and another **thread** **making** that **something** happen and then **signaling** that it has **happened**, thus **waking** the waiting **thread**.
>We are thus using the **semaphore** as an **ordering primitive**.